# 文件恢复程序设计文档

## 文件恢复原理分析

### 1. Linux文件系统删除机制
- 当使用`rm`删除文件时，文件系统只是将目录项（directory entry）标记为已删除
- inode和实际数据块并不会立即清零，只是标记为"可重用"
- 只要inode和数据块没有被新文件覆盖，数据就仍然存在磁盘上

### 2. 恢复可能性条件
- **时间窗口**：删除后到inode被重用之间的时间
- **磁盘活动**：系统写入越少，恢复成功率越高
- **文件系统类型**：ext4、xfs等不同文件系统的内部结构差异

## Go语言技术实现要点

### 1. 核心技术栈
```go
// 需要用到的主要包
import (
    "syscall"           // 系统调用
    "unsafe"            // 直接内存操作
    "os"               // 文件操作
    "golang.org/x/sys/unix"  // Unix系统调用扩展
)
```

### 2. 关键技术点

**低级文件系统访问**
- 使用`syscall.Open()`直接访问块设备（如/dev/sda1）
- 需要root权限读取原始磁盘数据
- 通过`syscall.Read()`读取磁盘扇区

**inode结构解析**
```go
type Inode struct {
    Mode     uint16    // 文件类型和权限
    Links    uint16    // 硬链接数
    Size     uint64    // 文件大小
    Blocks   uint64    // 占用的块数
    Dtime    uint32    // 删除时间 (关键!)
    // ... 其他字段
}
```

**文件系统超级块分析**
- 读取ext4超级块获取文件系统参数
- 计算inode表位置和块组描述符
- 确定每个inode的磁盘位置

### 3. 核心算法思路

**扫描策略**
1. 遍历所有inode
2. 检查`dtime`字段（删除时间）非零的inode
3. 验证inode结构完整性
4. 重建文件路径（通过父目录inode）

**数据完整性验证**
- 检查magic number
- 验证checksum
- 确认数据块链表完整性

### 4. Go语言特有考虑

**内存安全**
```go
// 使用unsafe包进行二进制数据解析
func parseInode(data []byte) *Inode {
    return (*Inode)(unsafe.Pointer(&data[0]))
}
```

**并发处理**
- 使用goroutine并行扫描不同的块组
- channel传递扫描结果
- sync.WaitGroup协调goroutine

**错误处理**
- Go的显式错误处理适合处理底层I/O错误
- 区分致命错误和可恢复错误

### 5. 实现挑战

**权限问题**
- 需要root权限访问块设备
- 使用`os.Getuid()`检查运行权限

**文件系统兼容性**
- 不同ext4版本的inode结构差异
- 需要解析文件系统特性标志

**性能优化**
- 批量读取减少syscall次数
- 使用mmap映射大文件提高效率

## 实现顺序建议

1. **项目初始化和基础结构**
2. **超级块读取和文件系统信息解析**
3. **inode结构定义和解析功能**
4. **已删除文件扫描逻辑**
5. **文件数据恢复功能**
6. **命令行界面和用户交互**